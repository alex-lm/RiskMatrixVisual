import { CompositeCard, SimpleCard } from "./FormattingSettingsComponents";
import { getLocalizedProperty } from "./utils/FormattingSettingsUtils";
export class FormattingSettingsService {
    constructor(localizationManager) {
        this.localizationManager = localizationManager;
    }
    /**
     * Build visual formatting settings model from metadata dataView
     *
     * @param dataViews metadata dataView object
     * @returns visual formatting settings model
     */
    populateFormattingSettingsModel(typeClass, dataView) {
        var _a, _b;
        const defaultSettings = new typeClass();
        const dataViewObjects = (_a = dataView === null || dataView === void 0 ? void 0 : dataView.metadata) === null || _a === void 0 ? void 0 : _a.objects;
        if (dataViewObjects) {
            // loop over each formatting property and set its new value if exists
            (_b = defaultSettings.cards) === null || _b === void 0 ? void 0 : _b.forEach((card) => {
                var _a;
                if (card instanceof CompositeCard)
                    (_a = card.topLevelSlice) === null || _a === void 0 ? void 0 : _a.setPropertiesValues(dataViewObjects, card.name);
                const cardGroupInstances = (card instanceof SimpleCard ? [card] : card.groups);
                cardGroupInstances === null || cardGroupInstances === void 0 ? void 0 : cardGroupInstances.forEach((cardGroupInstance) => {
                    var _a, _b, _c, _d;
                    // Set current top level toggle value
                    (_a = cardGroupInstance.topLevelSlice) === null || _a === void 0 ? void 0 : _a.setPropertiesValues(dataViewObjects, card.name);
                    (_b = cardGroupInstance === null || cardGroupInstance === void 0 ? void 0 : cardGroupInstance.slices) === null || _b === void 0 ? void 0 : _b.forEach((slice) => {
                        slice === null || slice === void 0 ? void 0 : slice.setPropertiesValues(dataViewObjects, card.name);
                    });
                    (_d = (_c = cardGroupInstance === null || cardGroupInstance === void 0 ? void 0 : cardGroupInstance.container) === null || _c === void 0 ? void 0 : _c.containerItems) === null || _d === void 0 ? void 0 : _d.forEach((containerItem) => {
                        var _a, _b;
                        (_a = containerItem === null || containerItem === void 0 ? void 0 : containerItem.slices) === null || _a === void 0 ? void 0 : _a.forEach((slice) => {
                            slice === null || slice === void 0 ? void 0 : slice.setPropertiesValues(dataViewObjects, card.name);
                        });
                        (_b = containerItem === null || containerItem === void 0 ? void 0 : containerItem.groups) === null || _b === void 0 ? void 0 : _b.forEach((group) => {
                            var _a, _b;
                            (_a = group === null || group === void 0 ? void 0 : group.topLevelSlice) === null || _a === void 0 ? void 0 : _a.setPropertiesValues(dataViewObjects, card.name);
                            (_b = group === null || group === void 0 ? void 0 : group.slices) === null || _b === void 0 ? void 0 : _b.forEach((slice) => {
                                slice === null || slice === void 0 ? void 0 : slice.setPropertiesValues(dataViewObjects, card.name);
                            });
                        });
                    });
                });
            });
        }
        return defaultSettings;
    }
    /**
     * Build formatting model by parsing formatting settings model object
     *
     * @returns powerbi visual formatting model
     */
    buildFormattingModel(formattingSettingsModel) {
        const formattingModel = {
            cards: []
        };
        formattingSettingsModel.cards
            .filter(({ visible = true }) => visible)
            .forEach((card) => {
            var _a;
            const formattingCard = {
                displayName: getLocalizedProperty(card, "displayName", this.localizationManager),
                description: getLocalizedProperty(card, "description", this.localizationManager),
                disabled: card.disabled,
                disabledReason: getLocalizedProperty(card, "disabledReason", this.localizationManager),
                groups: [],
                uid: card.name + "-card",
                analyticsPane: card.analyticsPane,
            };
            const objectName = card.name;
            this.setTopLevelToggleSliceClone(card, formattingCard, objectName);
            (_a = card.onPreProcess) === null || _a === void 0 ? void 0 : _a.call(card);
            const isSimpleCard = card instanceof SimpleCard;
            const cardGroupInstances = (isSimpleCard ?
                [card].filter(({ visible = true }) => visible) :
                card.groups.filter(({ visible = true }) => visible));
            cardGroupInstances === null || cardGroupInstances === void 0 ? void 0 : cardGroupInstances.forEach((cardGroupInstance) => {
                const formattingGroup = this.buildCardGroupInstances(cardGroupInstance, formattingCard, isSimpleCard, objectName);
                formattingCard.groups.push(formattingGroup);
            });
            formattingCard.revertToDefaultDescriptors = this.getRevertToDefaultDescriptor(card);
            formattingModel.cards.push(formattingCard);
        });
        return formattingModel;
    }
    buildCardGroupInstances(cardGroupInstance, formattingCard, isSimpleCard, objectName) {
        const groupUid = cardGroupInstance.name + "-group";
        // Build formatting group for each group
        const formattingGroup = {
            displayName: isSimpleCard ? undefined : getLocalizedProperty(cardGroupInstance, "displayName", this.localizationManager),
            description: isSimpleCard ? undefined : getLocalizedProperty(cardGroupInstance, "description", this.localizationManager),
            slices: [],
            uid: groupUid,
            collapsible: cardGroupInstance.collapsible,
            delaySaveSlices: cardGroupInstance.delaySaveSlices,
            disabled: cardGroupInstance.disabled,
            disabledReason: getLocalizedProperty(cardGroupInstance, "disabledReason", this.localizationManager),
        };
        // In case formatting model adds data points or top categories (Like when you modify specific visual category color).
        // these categories use same object name and property name from capabilities and the generated uid will be the same for these formatting categories properties
        // Solution => Save slice names to modify each slice uid to be unique by adding counter value to the new slice uid
        const sliceNames = {};
        // Build formatting container slice for each property
        if (cardGroupInstance.container) {
            const containerUid = formattingGroup.uid + "-container";
            const formattingContainer = this.buildContainerGroupInstance(cardGroupInstance.container, containerUid, objectName, sliceNames);
            formattingGroup.displayName = "Apply settings to";
            formattingGroup.sliceWithContainer = false;
            formattingGroup.collapsible = false;
            formattingGroup.container = formattingContainer;
        }
        if (cardGroupInstance.slices) {
            this.setTopLevelToggleSliceClone(cardGroupInstance, (formattingGroup.displayName == undefined ? formattingCard : formattingGroup), objectName);
            // Build formatting slice for each property
            this.buildFormattingSlices({ slices: cardGroupInstance.slices, objectName, sliceNames, formattingSlices: formattingGroup.slices });
        }
        return formattingGroup;
    }
    buildContainerGroupInstance(container, containerUid, objectName, sliceNames) {
        const formattingContainer = {
            displayName: getLocalizedProperty(container, "displayName", this.localizationManager),
            description: getLocalizedProperty(container, "description", this.localizationManager),
            containerItems: [],
            uid: containerUid
        };
        container.containerItems.filter(({ visible = true }) => visible).forEach((containerItem) => {
            if (!containerItem) { // This is to prevent error when container item is null or undefined
                return;
            }
            // Build formatting container item object
            const containerIemName = containerItem.displayNameKey ? containerItem.displayNameKey : containerItem.displayName;
            const containerItemUid = containerUid + containerIemName;
            const formattingContainerItem = {
                displayName: getLocalizedProperty(containerItem, "displayName", this.localizationManager),
                slices: [],
                groups: [],
                uid: containerItemUid
            };
            // Build formatting slices and add them to current formatting container item
            if (containerItem.slices) {
                this.buildFormattingSlices({ slices: containerItem.slices, objectName, sliceNames, formattingSlices: formattingContainerItem.slices });
            }
            // Build formatting groups and add them to current formatting container item
            if (containerItem.groups) {
                containerItem.groups.forEach((group) => {
                    const groupSlices = {
                        displayName: getLocalizedProperty(group, "displayName", this.localizationManager),
                        description: getLocalizedProperty(group, "description", this.localizationManager),
                        slices: [],
                        uid: group.name + "-container-group",
                        collapsible: group.collapsible,
                        delaySaveSlices: group.delaySaveSlices,
                        disabled: group.disabled,
                        disabledReason: getLocalizedProperty(group, "disabledReason", this.localizationManager)
                    };
                    this.setTopLevelToggleSliceClone(group, groupSlices, objectName);
                    this.buildFormattingSlices({ slices: group.slices, objectName, sliceNames, formattingSlices: groupSlices.slices });
                    formattingContainerItem.groups.push(groupSlices);
                });
            }
            formattingContainer.containerItems.push(formattingContainerItem); // pushes specific container item (All, name1, name2) with slices
        });
        return formattingContainer;
    }
    buildFormattingSlices({ slices, objectName, sliceNames, formattingSlices }) {
        // Filter slices based on their visibility
        slices === null || slices === void 0 ? void 0 : slices.filter(({ visible = true }) => visible).forEach((slice) => {
            const formattingSlice = slice === null || slice === void 0 ? void 0 : slice.getFormattingSlice(objectName, this.localizationManager);
            if (formattingSlice) {
                // Modify formatting slice uid if needed
                if (sliceNames[slice.name] === undefined) {
                    sliceNames[slice.name] = 0;
                }
                else {
                    sliceNames[slice.name]++;
                    formattingSlice.uid = `${formattingSlice.uid}-${sliceNames[slice.name]}`;
                }
                formattingSlices.push(formattingSlice);
            }
        });
    }
    getRevertToDefaultDescriptor(card) {
        var _a;
        // Proceeded slice names are saved to prevent duplicated default descriptors in case of using 
        // formatting categories & selectors, since they have the same descriptor objectName and propertyName
        const sliceNames = {};
        const revertToDefaultDescriptors = [];
        let cardSlicesDefaultDescriptors;
        let cardContainerSlicesDefaultDescriptors = [];
        // eslint-disable-next-line
        if (card instanceof CompositeCard && card.topLevelSlice)
            revertToDefaultDescriptors.push(...(_a = card.topLevelSlice) === null || _a === void 0 ? void 0 : _a.getRevertToDefaultDescriptor(card.name));
        const cardGroupInstances = (card instanceof SimpleCard ?
            [card].filter(({ visible = true }) => visible) :
            card.groups.filter(({ visible = true }) => visible));
        cardGroupInstances === null || cardGroupInstances === void 0 ? void 0 : cardGroupInstances.forEach((cardGroupInstance) => {
            var _a, _b;
            cardSlicesDefaultDescriptors = this.getSlicesRevertToDefaultDescriptor(card.name, cardGroupInstance.slices, sliceNames, cardGroupInstance.topLevelSlice);
            (_b = (_a = cardGroupInstance.container) === null || _a === void 0 ? void 0 : _a.containerItems) === null || _b === void 0 ? void 0 : _b.forEach((containerItem) => {
                var _a;
                cardContainerSlicesDefaultDescriptors = cardContainerSlicesDefaultDescriptors.concat(this.getSlicesRevertToDefaultDescriptor(card.name, containerItem.slices, sliceNames));
                (_a = containerItem.groups) === null || _a === void 0 ? void 0 : _a.forEach((group) => {
                    cardContainerSlicesDefaultDescriptors = cardContainerSlicesDefaultDescriptors.concat(this.getSlicesRevertToDefaultDescriptor(card.name, group.slices, sliceNames));
                });
            });
            revertToDefaultDescriptors.push(...cardSlicesDefaultDescriptors.concat(cardContainerSlicesDefaultDescriptors));
        });
        return revertToDefaultDescriptors;
    }
    getSlicesRevertToDefaultDescriptor(cardName, slices, sliceNames, topLevelSlice) {
        let revertToDefaultDescriptors = [];
        if (topLevelSlice) {
            sliceNames[topLevelSlice.name] = true;
            revertToDefaultDescriptors = revertToDefaultDescriptors.concat(topLevelSlice.getRevertToDefaultDescriptor(cardName));
        }
        slices === null || slices === void 0 ? void 0 : slices.forEach((slice) => {
            if (slice && !sliceNames[slice.name]) {
                sliceNames[slice.name] = true;
                revertToDefaultDescriptors = revertToDefaultDescriptors.concat(slice.getRevertToDefaultDescriptor(cardName));
            }
        });
        return revertToDefaultDescriptors;
    }
    setTopLevelToggleSliceClone(objectToClone, newParent, objectName) {
        if (objectToClone.topLevelSlice) {
            const topLevelToggleSlice = objectToClone.topLevelSlice.getFormattingSlice(objectName, this.localizationManager);
            topLevelToggleSlice.suppressDisplayName = true;
            newParent.topLevelToggle = topLevelToggleSlice;
        }
    }
}
export default FormattingSettingsService;
//# sourceMappingURL=FormattingSettingsService.js.map